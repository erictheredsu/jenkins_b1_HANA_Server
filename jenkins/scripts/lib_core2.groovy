// convert params to Groovy mapdef args = [:] << params// timing logsdef jobs = []// constant job namesdef SHELL_LINUX = "SHELL_LINUX"def SHELL_WIN32 = "SHELL_WIN32"def SYNC_SOURCE = "SYNC_SOURCE"def SYNC_JMX	= "SYNC_JMX"// job parametersdef env 				= build.properties.environmentdef WORKSPACE 			= env.WORKSPACEdef BUILD_NUMBER 		= env.BUILD_NUMBERdef JENKINS_HOME 		= env.JENKINS_HOMEdef BUILDS_POOL 		= env.BUILDS_POOLdef CURRENT_SPACE		= new File("${WORKSPACE}/${BUILD_NUMBER}")args.SLAVE_LINUX		= args.HDB_HOSTargs.BUILD_ZIP_FILE		= "\\\\${args.HDB_HOST}\\b1_shf\\Client.zip"def BUILD_MARK			= env.BUILDS_POOL /*env.MNT_PATH*/// extract output parametersdef extract = { String log, String newLine ->	def map = [:]    def lines = log.split(newLine)    def matchList = {        def matcher = ( it =~ /.*^!![A-Z_0-9]*=.*/ )        if (matcher.matches()) {            for (m in matcher) {                def a = m.split("=", 2)                map.put (a[0].substring(2), a[1])            }        }    }    lines.each(matchList)    return map}// shell execute commanddef shell = { cmd ->	out.println "shell execute command -> $cmd"	out.println "return -> " + cmd.execute().text}// save args to workspace for future usage (e.g. send mail)def saveEnv = { ->	new File("args.properties", CURRENT_SPACE).withWriter{ fs ->		args.each { fs.println it.toString().replace("\\", "\\\\") }	}}// invoke job, extract output parameters and inject into 'args'def invoke = { String job, String script, String node = args.SLAVE_LINUX ->	// begin of job	def timeStart = new Date()	out.println ""	out.println "======= Begin of ${job} -> ${script} @${node} ======="	// change node and script dynamically	args.JOB_EXECUTOR = node	args.JOB_SCRIPT = script	// save the env in case the workflow fails by unhandled exception	saveEnv()	// invoke job    def rs = build(args, job)    out.println rs.log	out.println "======= End of ${job} -> ${script} @${node} =======" 	// check result	assert rs.result.name == "SUCCESS"	// extract output parameters	def map = extract(rs.log, (job == SHELL_LINUX ? "\n" : "\r\n") )	for(cc in map) {		out.println "returns ${cc}"	}	args << map		out.println ""	// end of job	def timeStop = new Date() 	def elapsed = groovy.time.TimeCategory.minus(timeStop, timeStart) 	jobs << "job ${job} - ${script} @${node} took ${elapsed}"	return rs	}// display each job invocation elapseddef showTimeline = { ->	out.println ""	out.println "Workflow completed, now display job status;"	jobs.each { out.println it }	out.println ""}// setBuildStatedef setBuildState = { branch, pkg, state, clue ->	def dir = new File("${BUILD_MARK}${branch}/${pkg}")	if (!dir.exists()) {		dir.mkdirs()	}	def hr = new File(state, dir)	hr.write(clue)	return hr}// getBuildStatedef getBuildState = { branch, pkg, state ->	def dir = new File("${BUILD_MARK}${branch}/${pkg}")	if (!dir.exists()) {		dir.mkdirs()	}	return new File(state, dir).exists()}// isBuildRunningdef isBuildRunning = { branch, pkg ->	return getBuildState(branch, pkg, "InstallationRunning.txt")}// isBuildPasseddef isBuildPassed = { branch, pkg ->	return getBuildState(branch, pkg, "InstallationPassed.txt")}// isBuildFaileddef isBuildFailed = { branch, pkg ->	return getBuildState(branch, pkg, "InstallationFailed.txt")}// setBuildRunningdef setBuildRunning = { branch, pkg, clue ->	return setBuildState(branch, pkg, "InstallationRunning.txt", clue)}// unmarkBuildRunningdef unmarkBuildRunning = { branch, pkg ->	new File("${BUILD_MARK}${branch}/${pkg}/InstallationRunning.txt").delete()}// setBuildPasseddef setBuildPassed = { branch, pkg, clue ->	return setBuildState (branch, pkg, "InstallationPassed.txt", clue)}// setBuildFaileddef setBuildFailed = { branch, pkg, clue ->	return setBuildState (branch, pkg, "InstallationFailed.txt", clue)}// validate builddef validateBuild = { branch, pkg ->	assert !isBuildFailed (branch, pkg)}// check builddef checkBuild = { branch, ignoreFailure = false ->    // check available build    out.println "Checking ${branch} codeline..."        def rc = []    new File("${env.MNT_PATH}${branch}").eachDirMatch(~/.*HANA/) { dir ->        rc << dir    }         def top = rc.sort() { a, b ->        def x = (a.name.split('_').last() - ".HANA").toInteger()        def y = (b.name.split('_').last() - ".HANA").toInteger()        def r = y <=> x        if (r == 0) {            r = b.lastModified() <=> a.lastModified()        }        return r    }.dropWhile { dir ->    	def unexsits = !new File("build_copy_done.txt", dir).exists()    	if (unexsits) {    		return true    	}    	if (!ignoreFailure) {    		return isBuildFailed(branch, dir.name)    	}    	return false    }.first()        out.println "The latest build of ${branch} is ${top.name}"    return top.name	}// standardize the parameters e.g. trim the leading and trailing spacesdef polishArgs = { ->	args.HDB_HOST = args.HDB_HOST.trim()	args.HDB_INST = args.HDB_INST.trim()	args.HDB_USR = args.HDB_USR.trim()	args.BUILD_PKG = args.BUILD_PKG ? args.BUILD_PKG.trim() : ""}def preinit = { -> 		// create workspace with build number	CURRENT_SPACE.mkdir()		// save the env in case the workflow fails by unhandled exception	saveEnv()		polishArgs()}preinit()